<!doctype html>
<html lang="ko">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>PCK Audio Finder — Local GUI</title>
    <style>
      body{font-family:Segoe UI,Arial;margin:20px}
      .tabs{display:flex;gap:8px;margin-bottom:12px}
      .tab{padding:8px 12px;border:1px solid #ccc;border-bottom:none;cursor:pointer;background:#f5f5f5}
      .tab.active{background:#fff;font-weight:600}
      .panel{border:1px solid #ccc;padding:12px}
      label{display:block;margin-top:8px}
      textarea{width:100%;height:300px}
      .row{display:flex;gap:8px}
      .muted{color:#666;font-size:0.95em}
    </style>
  </head>
  <body>
    <h2>PCK Audio Finder — Local GUI</h2>

    <!-- Server shutdown button (local only) -->
    <button id="shutdown-server" title="Stop local web server" style="position:fixed;top:12px;right:12px;padding:6px 10px;background:#c33;color:#fff;border:none;border-radius:4px;cursor:pointer;z-index:1000">서버 종료</button>

    <div class="tabs" role="tablist">
      <div class="tab" data-tab="tab1" data-task="unpack">pck언팩</div>
      <div class="tab" data-tab="tab2" data-task="convert">wem 변환</div>
      <div class="tab active" data-tab="tab3" data-task="transcribe">wav 매핑</div>
      <div class="tab" data-tab="tab4" data-task="filter">맵 필터링</div>
    </div>

    <div id="tab1" class="panel" style="display:none">
      <h3>pck언팩</h3>
      <form class="ctl-form">
        <label>Input folder: <input name="input" value="input"/></label>
        <label>Output base: <input name="output" value="unpacked"/></label>
        <label>Runtime folder: <input name="runtime" value="runtime"/></label>
        <label>Workers: <input name="workers" value="0"/></label>
        <div class="row" style="margin-top:10px">
          <button type="button" class="start-btn">Start</button>
          <button type="button" class="stop-btn">Stop</button>
        </div>
      </form>
      <p class="muted">pck 파일을 찾아 자동으로 언팩하고 .bnk 내부도 추출합니다.</p>
    </div>

    <div id="tab2" class="panel" style="display:none">
      <h3>wem 변환</h3>
      <form class="ctl-form">
        <label>Input folder: <input name="input" value="input"/></label>
        <label>Site-packages: <input name="site-packages" value="runtime\Lib\site-packages"/></label>
        <label>Workers: <input name="workers" value="1"/></label>
        <label><input type="checkbox" name="overwrite"/> Overwrite existing</label>
        <label>Runtime folder: <input name="runtime" value="runtime"/></label>
        <div class="row" style="margin-top:10px">
          <button type="button" class="start-btn">Start</button>
          <button type="button" class="stop-btn">Stop</button>
        </div>
      </form>
      <p class="muted">폴더 내 모든 .wem 파일을 찾아 .wav로 변환합니다.</p>
    </div>

    <div id="tab3" class="panel">
      <h3>wav 매핑</h3>
      <!-- 기존 기능: transcribe 컨트롤 및 로그는 이 탭에 위치합니다. -->
      <form id="ctl" class="ctl-form">
        <label>Input folder: <input name="input" value="input"/></label>
        <label>Output TSV: <input name="tsv" value="results.tsv"/></label>
        <label>Model: <input name="model" value="small"/></label>
        <label>Device: 
          <select name="device">
            <option value="cpu">cpu</option>
            <option value="cuda">cuda</option>
          </select>
        </label>
        <label>Runtime folder: <input name="runtime" value="runtime"/></label>
        <div class="row" style="margin-top:10px">
          <button type="button" class="start-btn" id="start">Start</button>
          <button type="button" class="stop-btn" id="stop">Stop</button>
        </div>
      </form>
    </div>

    <div id="tab4" class="panel" style="display:none">
      <h3>맵 필터링</h3>
      <p class="muted">맵 필터 규칙을 적용하거나 미리보기할 수 있는 도구 영역입니다.</p>
      <p>현재는 자리 표시자입니다.</p>
    </div>

    <!-- 전역 로그: 탭과 상관없이 항상 보이도록 탭 영역 아래로 이동 -->
    <div id="global-log" class="panel" style="margin-top:12px">
      <h3>Log</h3>
      <textarea id="log" readonly></textarea>
    </div>

    <script>
      // Tab switching and task-aware log streaming
      const tabs = document.querySelectorAll('.tab');
      let es = null;
      function getActiveTask(){
        const tab = document.querySelector('.tab.active');
        return tab ? tab.getAttribute('data-task') || 'transcribe' : 'transcribe';
      }

      function showTab(which){
        ['tab1','tab2','tab3','tab4'].forEach(id=>{
          const el = document.getElementById(id);
          if(!el) return;
          el.style.display = (id===which)?'block':'none';
        });
      }

      function getActiveTabId(){
        const tab = document.querySelector('.tab.active');
        return tab ? tab.getAttribute('data-tab') : null;
      }

      function getActivePanel(){
        const id = getActiveTabId();
        return id ? document.getElementById(id) : null;
      }

        function setGlobalLogVisible(visible){
          const gl = document.getElementById('global-log');
          if(!gl) return;
          gl.style.display = visible ? 'block' : 'none';
        }

        // global helper to append a line to the shared log textarea
        window.appendLine = function(line){
          try{
            const ta = document.getElementById('log');
            if(!ta) return;
            ta.value += line + '\n';
            if(ta.value.length > 200000) ta.value = ta.value.slice(-200000);
            ta.scrollTop = ta.scrollHeight;
          }catch(e){ }
        }

      function openLogStreamFor(task){
        // do not open stream for the filter tab; ensure stream closed
        if(task === 'filter'){
          if(es){ try{ es.close(); }catch(e){} es = null; }
          return;
        }
        if(es){ try{ es.close(); }catch(e){} es = null; }
        try{
          es = new EventSource('/logs/stream?task='+encodeURIComponent(task));
          es.onmessage = (e)=>{ window.appendLine(e.data); };
          es.onerror = ()=>{};
        }catch(err){ es = null; }
      }

        tabs.forEach(t=>t.addEventListener('click', ()=>{
        document.querySelectorAll('.tab').forEach(x=>x.classList.remove('active'));
        t.classList.add('active');
        const which = t.getAttribute('data-tab');
        showTab(which);
        const task = getActiveTask();
        // hide log for filter tab, otherwise show and refresh status/stream
        if(task === 'filter'){
          setGlobalLogVisible(false);
          if(es){ try{ es.close(); }catch(e){} es = null; }
        }else{
          setGlobalLogVisible(true);
          window.fetchStatusAndStream(task);
        }
      }));

      async function post(path, data){
        const res = await fetch(path, {method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(data)});
        return res.json();
      }

      const ta = document.getElementById('log');

      function setButtons(running){
        const panel = getActivePanel();
        if(!panel) return;
        const startBtn = panel.querySelector('.start-btn');
        const stopBtn = panel.querySelector('.stop-btn');
        if(running){
          if(startBtn) startBtn.disabled = true;
          if(stopBtn) stopBtn.disabled = false;
        }else{
          if(startBtn) startBtn.disabled = false;
          if(stopBtn) stopBtn.disabled = true;
        }
      }

      // start buttons (one per tab)
      document.querySelectorAll('.start-btn').forEach(btn=>btn.addEventListener('click', async ()=>{
        const activeTask = getActiveTask();
        const panel = getActivePanel();
        const form = panel ? panel.querySelector('.ctl-form') || panel.querySelector('form') : null;
        const data = form ? Object.fromEntries(new FormData(form).entries()) : {};
        data.task = activeTask;
        // normalize checkbox value
        if(form){
          const ow = form.querySelector('input[name="overwrite"]');
          if(ow) data.overwrite = ow.checked;
        }
        const res = await post('/start', data);
        if(res){
          setButtons(!!res.started);
          if(typeof res.log === 'string'){
            ta.value = res.log || '';
            ta.scrollTop = ta.scrollHeight;
          }
        }
      }));

      // Shutdown server button (local only)
      const shutdownBtn = document.getElementById('shutdown-server');
      if(shutdownBtn){
        shutdownBtn.addEventListener('click', async ()=>{
          if(!confirm('정말로 로컬 웹서버를 종료하시겠습니까?')) return;
          try{
            shutdownBtn.disabled = true;
            shutdownBtn.textContent = '종료 중...';
            const res = await fetch('/shutdown', {method: 'POST'});
            try{ await res.json(); }catch(e){}
            // give server a moment to stop
            setTimeout(()=>{
              shutdownBtn.textContent = '서버 종료됨';
              shutdownBtn.disabled = true;
            }, 500);
          }catch(err){
            alert('서버 종료 요청에 실패했습니다. 콘솔을 확인하세요.');
            shutdownBtn.disabled = false;
            shutdownBtn.textContent = '서버 종료';
          }
        });
      }

      document.querySelectorAll('.stop-btn').forEach(btn=>btn.addEventListener('click', async ()=>{
        const activeTask = getActiveTask();
        const res = await post('/stop', {task: activeTask});
        if(res){
          setButtons(!res.stopped ? true : false);
          if(typeof res.log === 'string'){
            ta.value = res.log || '';
            ta.scrollTop = ta.scrollHeight;
          }
        }
      }));

      // Realtime log streaming via Server-Sent Events (SSE)
      (function(){
        const ta = document.getElementById('log');
        function appendLine(line){
          ta.value += line + '\n';
          // keep tail
          if(ta.value.length > 200000) ta.value = ta.value.slice(-200000);
          ta.scrollTop = ta.scrollHeight;
        }

        // helper: fetch status for a task and open stream
        window.fetchStatusAndStream = async function(task){
          // skip fetching status for filter tab
          if(task === 'filter'){
            ta.value = '';
            ta.scrollTop = ta.scrollHeight;
            setButtons(false);
            openLogStreamFor(task);
            return;
          }
          try{
            const r = await fetch('/status?task='+encodeURIComponent(task));
            const j = await r.json();
            ta.value = j.log || '';
            ta.scrollTop = ta.scrollHeight;
            setButtons(!!j.running);
          }catch(e){ }
          openLogStreamFor(task);
        }

        // Initially load status/stream for the default active task
        if(getActiveTask() === 'filter'){
          setGlobalLogVisible(false);
        }else{
          setGlobalLogVisible(true);
          window.fetchStatusAndStream(getActiveTask());
        }

        // Periodically poll status for active task to keep button state in sync
        setInterval(async ()=>{
          try{
            const task = getActiveTask();
            if(task === 'filter') return;
            const r = await fetch('/status?task='+encodeURIComponent(task));
            const j = await r.json();
            setButtons(!!j.running);
          }catch(e){}
        }, 1500);

        // fallback if EventSource not available: poll logs into textarea
        if(typeof(EventSource) === 'undefined'){
          setInterval(async ()=>{
            try{
              const task = getActiveTask();
              if(task === 'filter') return;
              const r = await fetch('/status?task='+encodeURIComponent(task));
              const j = await r.json();
              ta.value = j.log || '';
              ta.scrollTop = ta.scrollHeight;
            }catch(e){}
          }, 1500);
        }
      })();
    </script>
  </body>
</html>
